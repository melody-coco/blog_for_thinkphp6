<center>Linux理论</center>
详情[C语言中文网](http://c.biancheng.net/view/2952.html)



#### 1.	时间片

操作系统采用时间片轮转的方式处理用户的服务请求并在终端上显示结果（操作系统将CPU的时间划分为若干个片段，称为时间片），操作系统一时间片为单位，轮流为每个终端用户服务，每次服务一个时间片



#### 2.	类UNIX系统结构

硬件-->内核层(系统调用)-->Shell层(Shell命令)-->应用层(命令界面)-->用户

内核层：作用是在软件硬件中间联系，作为一个承上启下的作用，中间人

Shell层：是直接跟用户进行交互用户可以在提示符下输入命令行，由Shell解释执行并输					出相应结果或者有关信息，所以Shell又称为**命令解释器**



应用层：提通基于X Window协议的图形环境。X Window定义了一个系统所必须的功能			（就像tcp/ip，定义软件所具备的功能），简单的说就是图形化界面，桌面环境



PS. X Window不是微软的Windows

前者不安X Window可以节约大量系统资源，后者必须安装图形环境，微软的Windos图形环境和内核绑定



#### 3.	VMware的网络连接

+ 桥接模式：相当于虚拟机的网卡和宿主机的物理网卡都连接到虚拟机软件提供的VMnet0上，因此虚拟机和宿主机是平等的，相当于一个网络中的两台计算机，此种设置既可以保证虚拟机和宿主机的同行，也可以和局域网内的其他主机通信，还可以连接Internet，是限制最少的连接方式
+ NAT模式：相当于虚拟机的网卡和宿主机的虚拟网卡VMnet8连接到虚拟机软件所提供的VMnet8虚拟交换机上，因此主机是通过VMnet8虚拟网卡通信的。在这种网络结构中，VMware为虚拟机提供了一个虚拟的NAT服务器和一个虚拟的DHCP服务器，虚拟机利用这两个服务器可以连接到Internet，所以正常情况下，虚拟机系统只要设帝国自动获取IP地址，就技能和宿主机同行，又能连接到Internet了。但是此种设置不能连接到局域网内的其他主机。
+ 仅主机模式：宿主机和虚拟机通信使用的是VMware的虚拟网卡VMnet1，但是这种连接没有NAT服务器为虚拟机提供路由功能，所以仅主机网络只能连接宿主机，不能连接局域网，也不能连接Internet网络
+ 自定义网络：可以手动选择使用哪块虚拟机网卡。如果选择Vmnet1，就相当于桥接网络，如果选着VMnet8，就相当于NAT网络



#### 4.	Linux远程管理协议

常用的远程管理协议由以下4种：

+ RDP(remote desktop protocol)协议：远程桌面协议，，大部分Windows系统都默认支持此协议，Windows系统咋弄的远程桌面管理就基于该协议
+ RFB(remote FrameBuffer)协议：图形化远程管理协议，VNC(vitual network console)管理工具就基于此协议
+ Telnet：命令行界面远程管理协议，几乎所有的操作系统都默认支持该协议。此协议的特点是在进行数据传输时，使用明文方式
+ SSH(Secure Shell)协议：命令行界面远程管理协议，几乎所有操作系统都默认支持该协议。和Telnet不同，该协议在数据传输时会对数据进行加密并压缩，因此SSH协议，传输数据又快又安全



##### RDP对比RFB

+ 后者会在服务端将窗口在显存中画好，然后将图像传给客户端，客户端只需要将得到的图像进行解码显示即可

+ 前者将画图的工作交给客户端，服务端需要根据客户端的显示能力做适当的调整。



RFB适用于瘦客户端，RDP适用于低速客户端



#### 5.	linux一切皆文件

Linux中所有得内容都是以文件得形式保存管理的，即一切接文件，普通文件是文件，目录(windows下称为文件夹)是文件，硬件设备(设备，监视器，硬盘，打印机)是文件，就连套间字(sorket)，网络通信资源也是文件

Linux文件中，文件具体可分为以下几种类型

+ 普通文件：类似于mp4,pdf,html这样，可以直接拿来使用得文件都属于普通文件，linux用户可根据访问权限得不同可以对这些文件进行查看删除已经更改操作。
+ 目录文件：Linux系统中，目录包括了此目录中得各个文件得文件名已经指向这些文件得指针，打开目录等同于打开目录文件，只要你有权限，可以随意访问目录中得文件

`注意，目录文件的访问权限，同普通文件的执行权限，是一个意思。`

+ 字符设备文件和块设备文件

这些文件通常隐藏于/dev/ 目录下，当设备读取或外设交互时才会被使用

​		例如，磁盘光驱属于块设备文件，串口设备属于字符设备文件

`Linux系统中得所有设备，要么是块设备文件，要么是字符设备文件`

+ 套件字文件(socket)

套件字文件一般隐藏在 /var/run/目录下，用于进程间的网络通信

+ 符号链接文件(sysbolic link)

似于Windows中的快捷方式，是指向另一文件的简介指针(也就是软连接)



+ 管道文件(pipe)

主要用于进程间的通信。





#### 6.	挂载

首先Linux中一切皆文件，所以在Linux看来，任何的硬件设备也都是文件，它们各子有一套自己的文件系统(文件目录结构)。

当在Linux系统中使用这些硬件设备时，只有将Linux本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程叫做挂载。

`如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行无法找到`



注意：并不是跟目录下任何一个目录都可以作为挂载点，由于挂载操作哦会使得原有目录文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常，挂载点最好是新建的空目录



#### 7.	隐藏文件

在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“.”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“..”表示。

`如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找时，不显示该目录或文件。`



#### 8.	绝对路径，相对路径

绝对路径，相对路径没什么好说的。

简单要说的就是使用绝对路径的时候要带上`/`：

```shell
cd /root					//进入root目录,'/'表示根目录
```

相对路径还是那样，使用`..`

```shell
cd ../root
```





#### 9.	Linux文件名规则

简单说

+ 除了`/`字符外都可以使用，但是一般`<>?!`这些不用

+ 目录名不能超过255个字符
+ 目录和文件名区分大小写。dog，DOG和Dog是不同的目录或文件名，但一般不用大小写进行区分
+ 和Windows不一样，文件的扩展名，对Linux没有特殊含义，也就是说，Linux系统并不以文件的扩展名区分开文件类型。例如：dog.exe只是一个文件，其扩展名.exe并不代表此文件一定是可执行文件



以下是Linux系统中常见的硬件设备的文件名：

| 硬件设备      | 文件名称                                                     |
| ------------- | ------------------------------------------------------------ |
| IDE设备       | /dev/hd[a-d]，现在的 IDE设备已经很少见了，因此一般的硬盘设备会以 /dev/sd 开头。 |
| SCSI/SATA/U盘 | /dev/sd[a-p]，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。 |
| 软驱          | /dev/fd[0-1]                                                 |
| 打印机        | /dev/lp[0-15]                                                |
| 光驱          | /dev/cdrom                                                   |
| 鼠标          | /dev/mouse                                                   |
| 磁带机        | /dev/st0 或 /dev/ht0                                         |



#### 10.	Linux下识别文件类型

可以通过颜色来区分，这里不详解[详情](http://c.biancheng.net/view/5903.html)

只简单说一下命令查看：

```shell
ls -l
//查看当前目录下的所有文件及其类型
//首字母就是其类型
```

```shell
drwxr-xr-x 2 root 40 Jan 16 09:57 Desktop
drwxr-xr-x 2 root 40 Jan 16 09:57 Documents
drwxr-xr-x 2 root 40 Jan 16 09:57 Music
-rw-r--r-- 1 root 39 Jan 16 09:57 coco
drwxr-xr-x 2 root 40 Jan 16 09:57 Videos
		//此处的d表示文件是一个directory	目录
		//-表示是一个普通文件
```

| 第一个字符 | 文件类型                                                     |
| ---------- | ------------------------------------------------------------ |
| -          | 普通文件，包括纯文本文件、二进制文件、各种压缩文件等。       |
| d          | 目录，类似 Windows 系统中的文件夹。                          |
| b          | 块设备文件，就是保存大块数据的设备，比如最常见的硬盘。       |
| c          | 字符设备文件，例如键盘、鼠标等。                             |
| s          | 套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。 |
| p          | 管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。 |
| l          | 链接文件，类似 Windows 系统中的快捷方式。                    |





#### 11.	命令提示符！！！

登录系统后，第一眼看到的是

```shell
[root@localhost ~]#
```

具体含义如下：

+ []：这里是提示符的分割符号，没有特殊含义。
+ root：显示的是当前登录的用户，我这里用的是`root`登录
+ @：分隔符号，没什么特殊意义。
+ localhost：当前系统的简写主机名(完整主机名是localhost.localdomain)。
+ ~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录。
+ #：命令提示符，Linux用这个符号表示登录的用户权限等级。如果是超级用户，提示符就是#；普通用户，提示符就是$



家目录(又称为主目录)是什么？ Linux系统是纯字符界面，用户登录后，要有一个初始登录位置，这个初始登录位置就称为用户的家。

+ 超级用户的家目录：/root。
+ 普通用户的家目录：/home/用户名。



##### 命令行的基本格式

```shell
[root@localhost ~]# 命令[选项][参数]
```

命令格式中[]代表可选项，也就是说有些命令可以不写选项或参数



###### (1).选项的作用

ls命令后不加参数和选项也能执行，不过只能执行最基本的功能，即显示额当前目录下的文件名。那么加如一个选项，会出现什么结果。

```
[root@localhost ~]# ls -l
-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg
-rw-r--r--.1 root root 24772 1 月 14 18:17 install.log
-rw-r--r--.1 root root 7690 1 月 14 18:17 install.log.syslog
```

加了一个选项`-l`后，发现看到的内容变多了。`-l`是长格式(long list)的意思。可以看到，选项的作用是调整命令功能，有了选项后，则可以显示更丰富的数据



Linux的选项又分为短格式选项，(-l)和长格式选项(--all)。短格式选项就是英文的简写，用一个减号调用，例如：

```
[root@localhost ~]# ls -l
```



而长格式则是英文完整单词,一般用两个减号使用,例如：

```
[root@localhost ~]# ls --all
```

一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如`ls`命令的短格式选项`-l`就没有对应的长格式选项。





参数的作用就不说了额（ps.懂的都懂）





#### 12.	ext文件系统

软，硬链接 `In`命令



使用一张示意图来描述`ext4`文件系统(`Linux`文件系统)，如图：

<img src="http://c.biancheng.net/uploads/allimg/180928/2-1P92Q6130RO.jpg" alt="ext4文件系统示意图" style="zoom:67%;" />

ext4文件系统会把分区主要分为两大部分(暂时不提超级块)：小部分用于保存文件得inode（i节点）信息；剩余得大部分用于保存block信息。文件和目录都是这样保存的，



目录也有自己的inode和block，目录的block保存的不是具体的内容，而是目录下一级目录，一级文件的inode和对应的文件，目录名。(ps.文件名保存在文件的block和他所在目录的block)



##### inode

`inode`的默认大小为128byte，用来记录文件的权限(r,w,x)，文件的所有者和属组，文件大小，文件的状态改变时间(ctime)，文件最后一次读取的时间(atime)，文件的最近一次修改时间(mtime)，文件的数据真正保存的block编号。每个文件需要占用一个inode。**注意**：inode是不记录文件名的，那是因为文件名记录在文件所在目录的block中



##### block

block的大小可以是1kb，2kb，4kb，默认为4kb。block用于储存实际的数据储存，如果一个block放不下数据，则可以占用多个block。例如，有一个10kb的文件需要储存，则会占用3个block，虽然 最后一个block不hi占满，但也不能再放入其他文件的数据。这3个block可能是连续的，也可能是分散的.



由此，我们可以知道以下2个重要信息：

1.每个文件都独自占用一个inode，文件内容由inode的记录来指向；

2.如果想要读取文件的内容，就必须借助目录中记录的文件名来找到该文件的inode，才能成功找到文件内容所在的block块



了解了Linux系统底层的储存状态后，接下来学习In命令

In命令用于给文件创建链接, 根据Linux系统储存文件的特点 ,链接分以下2种方式：

+ 软连接：类似于Windows系统厚葬给文件创建快捷方式，即产生一个特殊文件，该文件用来指向另一个文件，此链接方式同样适用于目录。

  

  我的理解：(ps.说白了就是创建一个目标文件，文件的内容为源文件的inode)，点击目标文件就能访问源文件，目标文件的inode和源文件的inode是不一样的。说白了和硬链接比就是一个文件





+ 硬链接：我们知道，文件的基本信息都储存在inode种，而硬链接指的就是给一个文件的inode分配多个文件名，通过任何一个文件名，都可以找到此文件的inode，从而读取该文件的数据信息



​		我的理解：上面说了软连接说白了就是一个放inode的文件，而这里的硬链接就是一个指向源文件block的 inode。这和源文件的inode其实是一样的，都是直接各子目录的block中指向同一块block的inode。



##### 最简单的区别：

软连接本身是一个文件，有inode和block。block里面指向源文件的inode。

硬链接本身只是一个inode，他指向的和源文件inode指向的是同一块block。

​				以至于删除源文件，硬链接还是可以执行源文件的block。(ps.删除源文件，软连接会失效)	，说白了一个指 指针，一个指内存

[不懂,或想了解详细。以后忘了也最好看看](http://c.biancheng.net/view/740.html)

(ps.判断权限也是在访问inode时确定的，也就是说想要进某文件，首先会从inode中判断权限问题)





#### 13.	环境变量

对了，要说明使用的是环境变量，而不是字符串的话。需要在变量名的前面加一个`$`符号

```shell
[root@localhost ~]# echo $MAIL
```



##### 什么是环境变量

变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在`Linux`系统中，环境变量是用来定义系统运行的一些参数,比如每个用户不同的家目录(HOME)，邮件存放的位置(MAIL)

> LInux系统中，环境变量的名称一般都是大写

我们可以使用`env`命令来查看`Linux`系统中所有的环境变量，

```shell
[root@localhost ~]# env
```



`Linux`系统能够正常的运行并且为用户提供服务，需要数百个环境变量一起工作，没必要全部学习只学习一部分就够了

| 环境变量名称 | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| HOME         | 用户的主目录（也称家目录）                                   |
| SHELL        | 用户使用的 [Shell](http://c.biancheng.net/shell/) 解释器名称 |
| PATH         | 定义命令行解释器搜索用户执行命令的路径                       |
| EDITOR       | 用户默认的文本解释器                                         |
| RANDOM       | 生成一个随机数字                                             |
| LANG         | 系统语言、语系名称                                           |
| HISTSIZE     | 输出的历史命令记录条数                                       |
| HISTFILESIZE | 保存的历史命令记录条数                                       |
| PS1          | Bash解释器的提示符                                           |
| MAIL         | 邮件保存路径                                                 |



想要自己创建，环境变量的话。使用`export`命令。具体用法自己看`Linux`命令



##### PATH环境变量及其作用



先使用`which`命令查找以下`ls`的绝对路径：

```shell
[root@localhost ~]# which ls
alias ls='ls --color=auto'
        /bin/ls					//此处查找到了是在/bin目录下
```



有一个问题，就是为什么无论在哪个目录使用`ls`，`cd`，`rm`都可以使用喃。而不需要完整的指出命令的位置.

为什么`ls`命令不是`/bin/ls`这样写喃。

其实这是因为`PATH`环境变量在起作用。



首先执行以下命令：

```
[root@localhost ~]# echo $PATH
/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin
```

​	可以看到，PATH环境变量的内容是一堆目录组成的，各目录之间用冒号`:`隔开。当执行某个命令时，Linux会依照`PATH`中包含的目录依次搜寻该命令的可执行文件，一旦找到，则正常执行；反之，则提示无法找到该命令。



实例1：

我们试试把ls命令移动到其他的目录去，看看还能不能执行

```shell
[root@localhost ~]# mv /bin/ls /root   
									//bin下面的ls移动到root目录去
[root@localhost ~]# ls
bash: ls:command not found				//显示找不到命令
```



此时如果还想使用`ls`命令的话，有2种办法， 一种是直接将`/root`添加到PATH环境变量中去。例如：

```shell
[root@localhost ~]# PATH=$PATH:/root   //将/root添加到PATH环境变量中
[root@localhost ~]# echo $PATH 
/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root
[root@localhost ~]# ls
Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
```

>  ps.此种方法只是临时有效，一旦退出重新登录，就会失效



第二种方法，以绝对路径的方式来使用命令:

```shell
[root@localhost ~]# /root/ls			//使用绝对路径的方式来，使用ls
Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
```



当然为了不影响系统，最好还是把他给迁回去

```shell
[root@localhost ~]# mv /root/ls /bin
```



#### 14.	打包压缩

对于所有的压缩命令而言。都可以直接的压缩文件，而如果是目录的话，则需要进行打包了后，才能进行压缩操作





#### 15.	重定向

首先，Linux中标准默认输入设备是键盘，标准默认输出设备是显示器。而输入输出重定向，字面意思去理解，也就是：

+ 输入重定向：指的是重新指定设备来代替键盘作为新的输入设备
+ 输出重定向：指的是重新指定设备来代替显示器作为新的输入设备

> 通常是用文件或命令的执行结果来代替键盘作为新的输入设备，而新的输出设备通常指的就是文件。





##### Linux输入重定向

对于输入重定向来说，其需要用到的符号已经作用如下表所示

| 命令符号格式           | 作用                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 命令 < 文件            | 将指定文件作为命令的输入设备                                 |
| 命令 << 分界符         | 表示从标准输入设备（键盘）中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符其实就是自定义的字符串 |
| 命令 < 文件 1 > 文件 2 | 将文件 1 作为命令的输入设备，该命令的执行结果输出到文件 2 中。 |





实例1：

> 使用文件代替键盘作为输入设备

```shell
[root@localhost ~]# cat /etc/passwd		

[root@localhost ~]# cat /etc/passwd
```





实例2：

> 使用分界符，来限制输入

```shell
[root@localhost ~]# cat << !
>>系统会自动的提示输入
```

> 此时只要不输入`!`，系统就会一直的提示输入



实例3：

> 使用`命令<文件1> 文件2`，

```
[root@localhost ~]# cat <test1> test2
//输入test1然后输出test2，也就是test1的内容输出到了test2中
//				test2就和test1的内容一样了
```





##### Linux输出重定向

相对于输入重定向来说，输出重定向使用的更多。而且，和输入重新向不同的是，输出重定向还可以细分为标准输出重定向和错误输出重定向两种技术



命令符号格式如下：

| 命令符号格式                         | 作用                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 命令 > 文件                          | 将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据。 |
| 命令 2> 文件                         | 将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据。 |
| 命令 >> 文件                         | 将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将写入到原有内容的后面。 |
| 命令 2>> 文件                        | 将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将写入到原有内容的后面。 |
| 命令 >> 文件 2>&1 或者 命令 &>> 文件 | 将标准输出或者错误输出写入到指定文件，如果该文件中已包含数据，新数据将写入到原有内容的后面。注意，第一种格式中，最后的 2>&1 是一体的，可以认为是固定写法。 |



简单说，第一种`>`是输出重定向，并且覆盖，也就是清空写入。

第二种`>>`是输出重定向，并且不覆盖，也就是追加写入。

第三种 `2`，则代表的是输出结果类型，有`2`的话，表示的是写入的是错误信息(此时正常信息不能写入)

第四种`&>>`表示，无论是错误输出，还是标准输出都能输出到文件当中







实例1：

>对上面的所有都使用一遍

新建一个包含有 "Linux" 字符串的文本文件 Linux.txt，以及空文本文件 demo.txt，然后执行如下命令：

```

[root@localhost ~]# cat Linux.txt > demo.txt
[root@localhost ~]# cat demo.txt
Linux
[root@localhost ~]# cat Linux.txt > demo.txt
[root@localhost ~]# cat demo.txt
Linux     <--这里的 Linux 是清空原有的 Linux 之后，写入的新的 Linux
[root@localhost ~]# cat Linux.txt >> demo.txt
[root@localhost ~]# cat demo.txt
Linux
Linux     <--以追加的方式，新数据写入到原有数据之后
[root@localhost ~]# cat b.txt > demo.txt
cat: b.txt: No such file or directory  <-- 错误输出信息依然输出到了显示器中
[root@localhost ~]# cat b.txt 2> demo.txt
[root@localhost ~]# cat demo.txt
cat: b.txt: No such file or directory  <--清空文件，再将错误输出信息写入到该文件中
[root@localhost ~]# cat b.txt 2>> demo.txt
[root@localhost ~]# cat demo.txt
cat: b.txt: No such file or directory
cat: b.txt: No such file or directory  <--追加写入错误输出信息
```

